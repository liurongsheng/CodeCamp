# 什么是设计模式？

通俗来讲，设计模式就是针对某一种特殊场景而给出的标准解决方案，
它是前辈们的经验性总结，也是实现软件工程化的基础，良好的设计模式应用,
可以是我们的软件变得更加健壮可维护

设计模式按照类型划分可以分为三大类，如下所示：

- 创建型设计模式：如同它的名字那样，它是用来解耦对象的实例化过程
- 结构型设计模式：将类和对象按照一定规则组合成一个更加强大的结构体
- 行为型设计模式：定义类和对象的交互行为

23 种设计模式划分如下图所示：

创建型设计模式: (6 种)

    单例模式
    建造者模式
    原型模式
    工厂模式
    抽象工厂模式

结构型设计模式: (7 种)

    适配模式
    组合模式
    装饰模式
    外观模式
    桥接模式
    享元模式
    代理模式

行为型设计模式：(11 种)

    模板模式
    解释器模式
    策略模式
    状态模式
    观察者模式
    备忘录模式
    中介模式
    命令模式
    访问者模式
    责任链模式
    迭代器模式

[图片](http://op2fjznlf.bkt.clouddn.com/design_pattern.png)

## 设计原则

### 一.单一职责原则 (Single Responsibility Principle)

单一职责原则有什么好处：

- 类的复杂性降低，实现什么职责都有清晰明确的定义；
- 可读性提高，复杂性降低，那当然可读性提高了；
- 可维护性提高，可读性提高，那当然更容易维护了；
- 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

ps：接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异

### 二.里氏替换原则 (Liskov Substitution Principle)

定义：所有引用基类的地方必须能透明地使用其子类的对象。

通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类
还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
定义中包含的四层含义：

    - 子类必须完全实现父类的方法
    - 子类可以有自己的个性
    - 覆盖或实现父类的方法时输入参数可以被放大,
       如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，
       因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴
    - 覆写或实现父类的方法时输出结果可以被缩小
       父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，
       那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类

### 三.接口隔离原则 (Interface Segregation Principle)

接口分为两种：

- 实例接口（Object Interface）：Java 中的类也是一种接口
- 类接口（Class Interface）： Java 中经常使用 Interface 关键字定义的接口

隔离：建立单一接口，不要建立臃肿庞大的接口；即接口要尽量细化，同时接口中的方法要尽量少
接口隔离原则与单一职责原则的不同：接口隔离原则与单一职责的审视角度是不相同的，
单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少

### 四.依赖倒置原则 (Dependence Inversion Principle)

原始定义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节（实现类）
- 细节应该依赖抽象

依赖倒置原则在 java 语言中的体现：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
- 接口或抽象类不依赖于实现类
- 实现类依赖接口或抽象类

依赖的三种写法：

- 构造函数传递依赖对象（构造函数注入）
- Setter 方法传递依赖对象（setter 依赖注入）
- 接口声明依赖对象（接口注入）

使用原则：
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，
我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生（只要不超过两层的继承是可以忍受的）
- 尽量不要复写基类的方法
- 结合里氏替换原则使用

### 五.开闭原则 (Open Closed Principle)

定义：软件实体应该对扩展开放，对修改关闭
其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化
软件实体：项目或软件产品中按照一定的逻辑规则划分的模块、抽象和类、方法变化的三种类型：

- 逻辑变化
  只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是 a*b+c，现在需要修改为 a*b\*c，
  可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖或关联类都按照相同的逻辑处理

- 子模块变化
  一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，
  因此在通过扩展完成变化时，高层次的模块修改是必然的

- 可见视图变化
  可见视图是提供给客户使用的界面，如 JSP 程序、Swing 界面等，该部分的变化一般会引起连锁反应（特别
  是在国内做项目，做欧美的外包项目一般不会影响太大）。可以通过扩展来完成变化，这要看我们原有的设计是否灵活
