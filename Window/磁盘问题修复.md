# 磁盘问题修复

对于大部分用户而言，出现数据丢失的情况以后，他们并不知道如何处理，往往心急如焚，不知所措

利用 `DBR` 分区数据来尝试恢复分区，NTFS系统的 `DBR` 标志为`EB 52 90`，使用 WinHex 搜索-查找 16 进制数值 `EB5290`

- FAT32，标志 `EB 58 90`
- NTFS，标志 `EB 52 90`

```text
dbr 的 28 至 2f 保存的是文件系统扇区总数，通过数据解释器查看该分区扇区总数为 409,599，
这里使用当前扇区 128 加上 409,599 再加上 1 得到下一个分区的位于第 409,728 扇区

跳转至第409,728扇区，该扇区头部发现DBR标志EB 52 90，验证了我们计算的扇区大小的正确性。
```

<https://zhuanlan.zhihu.com/p/485713280>

<https://blog.csdn.net/anquanfun/article/details/128540738>

## 基本原理

- 盘片(Platter)
- 磁头(Head) 从 0 开始顺序编号
- 磁道(Track) 磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫磁道，磁道从外向内从 0 开始顺序编号
- 柱面(Cylinder) 所有盘面上同一磁道构成一个圆柱，这个就是柱面，每个圆柱上的磁头由上到下从 0 开始编号
- 扇区(Sector) 样式类似同心圆的磁道被划分为一段段的圆弧，每段圆弧叫做一个扇区，扇区从 1 开始编号，每个扇区中的数据作为一个单元同时读出或写入

同样的转速，外圈的磁道是比较快的

柱面的磁道切换只需要电子切换磁头，选取柱面需要通过机械切换

所以通常是一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后才移到下一个柱面，从下一个柱面的 1 扇区开始写数据

硬盘容量 = `盘面数 * 柱面数 * 扇区数 * 512 字节`

字节 Byte: 1TB = 2^10 GB = 2^20 MB = 2^30 KB = 2^40 B = 1099511627776 Byte

十六进制: 0 ~ 9, A(10), B(11), C(12), D(13), E(14), F(15)

一个扇区主要由两个部分组成

- 存储数据地点的标识符，扇区头包含扇区的三维地址(圆柱、磁头、扇区)和物理扇区包含一个不良扇区的标志，扇区头以一个 CRC 数值结尾，用来确定扇区头已经正确读出
- 存储数据的数据段，可分为数据和保护数据的结错码 ECC

### 硬盘低级格式化 (low level format) 简称低格，也称硬盘物理格式化(physical format)

- 检测硬盘磁介质
- 划分磁道
- 为硬盘的每个磁道按指定的交叉因子间隔划分扇区
- 将扇区 ID 放置道每个磁道上，完成对扇区的设置
- 对硬盘表面进行测试，对已损坏的磁道和扇区做标记
- 给硬盘中的每个扇区写入某一 ASCII 码字符

硬盘低级格式化对硬盘有较大的磨损，影响其使用寿命，一般不轻易考虑格式化

### 硬盘数据结构

MBR 区，即主引导记录区，位于整个硬盘的 0 磁道 0 柱面 1 扇区。在总共 512 字节的主引导扇区中，MBR的引导程序占用其中的前 446 个字节 (偏移 0 ~ 1BDH)，随后的 64 个字节(偏移 1BEH ~ 1FDH) 为 DPT(Disk Partition Table，硬盘分区表)，最后两个字节 "55 AA" (偏移 1FEH ~ 1FFH)是分区有效结束标志。它们共同组成硬盘主引导记录，也称为主引导扇区

DBR 区，DBR(DOS Boot Record)即操作系统引导记录区，通常位于硬盘 0 柱 1 面 1 扇区，是操作系统可以直接访问的第一个扇区

通过主引导记录定义的硬盘分区表，最多只能描述4个分区，微软为了解决这个问题，采用了虚拟MBR技术，在主MBR定义分区的时候，将多余的容量定义为拓展分区，指定该拓展分区的起止位置，根据起始位置指向的硬盘的某一个扇区，作为下一个分区表项，接着在该扇区继续定义分区。如果只有一个分区就定义该分区然后结束，如果不止一个分区，就定义一个基本分区和一个拓展分区，拓展分区再指向下一个分区描述扇区，在该扇区上按照上述原则继续定义分区，直到分区定义结束

NTFS (New Technology File System)文件系统：
在1993年随 Windows NT的第一个版本推出而面世，是一个性能优良的文件系统。基于可恢复文件结构而设计，可使用户数据文件不会有丢失或毁坏的危险

使用 卷 这个术语来表示一个逻辑磁盘，不必是一个相邻的磁盘，利用 B-Tree 文件管理方法来跟踪文件在磁盘上的位置，这种技术比先前的链表技术有更多的优越性。文件名顺序存放，因而查找速度更快。也使用 簇 作为最小的分配单位，簇的大小也称簇因子，由 NTFS 格式化程序确定，NFTS支持的簇大小为 512、1024、2048、4096个字节

硬盘启动时首先由 BIOS 读入 MBR 的内容，以确定各个逻辑驱动器及初始参数，然后调入活动分区的DBR，将控制权交给 DBR

## NTFS文件系统结构

原则：磁盘上任何事物都为文件

文件按簇进行分配，一个簇必须是物理扇区的整数倍，而且总是2的整数次方

在 NTFS 中，所有存储在卷上的数据都包含在文件中，包括用来定位和获取文件的数据结构，引导程序以及记录卷自身大小和使用情况的位图文件，在文件中存储一切使得文件系统很容易定位和维护数据

文件通过主文件表(MFT, Master File Table)来确定在其磁盘上的存储位置，主文件表示一个与文件相对应得数据库，卷中的每一个文件都有一个文件记录。主文件表自身也有它自己的文件记录

MFT中文件记录大小一般是固定的，不管簇的大小是多少，均为1KB，这个概念相当于Linux中的inode(i节点)。文件记录在MFT文件记录数组中物理上是连续的，且从0开始编号，MFT仅供系统本身组织、架构文件系统使用，这在NTFS中被称为元数据，是存储在卷上支持文件系统格式管理的数据，不能被应用程序访问，只能为系统提供服务

MFT的前16个元数据文件非常重要，为防止数据丢失，NFTS系统在卷存储中部对它们进行了备份

NTFS 分区的区域关系：

- Partition boot sector 分区引导扇区
- Master file table 主文件表
- System files 系统文件
- File area 文件区域

NTFS 使用逻辑簇号(LCN, Logical Cluster Number)和虚拟簇号(VCN, Virtual Cluster Number)来对簇进行定位，LCN是对整个卷中所有的簇从头到尾所进行的简单编号。用卷因子乘以LCN，NTFS就能够得到卷上的物理字节偏移量，从而得到物理磁盘的地址。VCN则是对属于特定文件的簇从头到尾进行编号，以便于引用文件中的数据

### NTFS DBR 参数

```DBR
Offset       0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F

000000000   EB 52 90 4E 54 46 53 20  20 20 20 00 02 08 00 00   隦 NTFS         
000000010   00 00 00 00 00 F8 00 00  3F 00 FF 00 00 10 00 00        ? ?      
000000020   00 00 00 00 80 00 80 00  C0 27 F9 0D 00 00 00 00       € € ??    
000000030   00 00 0C 00 00 00 00 00  02 00 00 00 00 00 00 00                   
000000040   F6 00 00 00 01 00 00 00  CF 5B 05 00 67 3C 0D 00   ?      蟍  g<  
000000050   00 00 00 00 FA 33 C0 8E  D0 BC 00 7C FB 68 C0 07       ?缼屑 |鹔?
000000060   1F 1E 68 66 00 CB 88 16  0E 00 66 81 3E 03 00 4E     hf 藞   f >  N
000000070   54 46 53 75 15 B4 41 BB  AA 55 CD 13 72 0C 81 FB   TFSu 碅华U?r  ?
000000080   55 AA 75 06 F7 C1 01 00  75 03 E9 DD 00 1E 83 EC   U猽 髁  u 檩  冹
000000090   18 68 1A 00 B4 48 8A 16  0E 00 8B F4 16 1F CD 13    h  碒?  嬼  ?
0000000A0   9F 83 C4 18 9E 58 1F 72  E1 3B 06 0B 00 75 DB A3   焹?瀀 r?   u郏
0000000B0   0F 00 C1 2E 0F 00 04 1E  5A 33 DB B9 00 20 2B C8     ?    Z3酃  +?
0000000C0   66 FF 06 11 00 03 16 0F  00 8E C2 FF 06 16 00 E8   f       幝   ?
0000000D0   4B 00 2B C8 77 EF B8 00  BB CD 1A 66 23 C0 75 2D   K +葁锔 煌 f#纔-
0000000E0   66 81 FB 54 43 50 41 75  24 81 F9 02 01 72 1E 16   f 鸗CPAu$ ? r  
0000000F0   68 07 BB 16 68 52 11 16  68 09 00 66 53 66 53 66   h ?hR  h  fSfSf
000000100   55 16 16 16 68 B8 01 66  61 0E 07 CD 1A 33 C0 BF   U   h?fa  ?3揽
000000110   0A 13 B9 F6 0C FC F3 AA  E9 FE 01 90 90 66 60 1E     滚 ?  f` 
000000120   06 66 A1 11 00 66 03 06  1C 00 1E 66 68 00 00 00    f? f     fh   
000000130   00 66 50 06 53 68 01 00  68 10 00 B4 42 8A 16 0E    fP Sh  h  碆? 
000000140   00 16 1F 8B F4 CD 13 66  59 5B 5A 66 59 66 59 1F      嬼?fY[ZfYfY 
000000150   0F 82 16 00 66 FF 06 11  00 03 16 0F 00 8E C2 FF    ? f       幝
000000160   0E 16 00 75 BC 07 1F 66  61 C3 A1 F6 01 E8 09 00      u? fa谩?? 
000000170   A1 FA 01 E8 03 00 F4 EB  FD 8B F0 AC 3C 00 74 09   → ? 綦龐瓞< t 
000000180   B4 0E BB 07 00 CD 10 EB  F2 C3 0D 0A 41 20 64 69   ?? ?腧? A di
000000190   73 6B 20 72 65 61 64 20  65 72 72 6F 72 20 6F 63   sk read error oc
0000001A0   63 75 72 72 65 64 00 0D  0A 42 4F 4F 54 4D 47 52   curred   BOOTMGR
0000001B0   20 69 73 20 63 6F 6D 70  72 65 73 73 65 64 00 0D    is compressed  
0000001C0   0A 50 72 65 73 73 20 43  74 72 6C 2B 41 6C 74 2B    Press Ctrl+Alt+
0000001D0   44 65 6C 20 74 6F 20 72  65 73 74 61 72 74 0D 0A   Del to restart  
0000001E0   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00                   
0000001F0   00 00 00 00 00 00 8A 01  A7 01 BF 01 00 00 55 AA         ???  U?
```

```DBR_01
 0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F
EB 52 90 4E 54 46 53 20  20 20 20 00 02 08 00 00
```

- 00~02: JMP 及 NOP; 不用修改
- 03~0A: OEM标志；不用修改
- 0B~0C: 每扇区字节数；不用修改
- 0D: 每簇扇区数；需要修改, 分区 2049MB 以上，默认每簇扇区数为 8，这里的数值一般为 08
- 0E~0F: 保留扇区；总是0，不用修改

- 10~12: 总为0，不用修改
- 13~14: NTFS未使用，为0；不用修改
- 15: 介质描述；F8；不用修改
- 16~17: 总为0；不用修改
- 18~19: 每磁道扇区数；一般不用修改
- 1A~1B: 磁头数；一般不用修改
- 1C~1F: 隐藏扇区；由分区表计算

- 20~23: NTFS未使用，为0；不用修改
- 24~27: NTFS未使用，为0；不用修改
- 28~2F: 扇区总数，由分区表计算

- 30~37: $MFT 的逻辑簇号，需要修改,

  可以通过查找 $MFT 的特征字符来定位，其起始4个Byte一定是`46 49 4C 45`,
  $MFTMirr 和 $MFT 的特征字符一样，区别是这两个区域的大小，大的是$MFT，小的是$MFTMirr，
  因为 $MFTMirr 只是 $MFT 的部分备份(前16个记录)而不是完全备份，一般 $MFT 在前面

- 38~3F: $MFTMirr 的逻辑簇号，需要修改

- 40~43: 每 MFT 记录簇号，需要修改

  找到  $MFT 后这个值就很简单了，相邻两个 $MFT 的特征字符之间的扇区按簇大小换算成簇数就是一个  $MFT 记录所占用的簇数

- 44~47: 每索引簇数，需要修改

  两个索引之间的扇区按簇大小换算成簇数就是每个索引所占用的簇数

- 48~4F: 卷标：不用修改

- 50~53: 校验和, 为0；不用修改
