# 模式

## 广度优先遍历

```js
// 定义节点类
class Node {
  constructor(value) {
    this.value = value;
    this.parent = null;
    this.children = [];
  }

  addChild(childNode) {
    this.children.push(childNode);
    childNode.parent = this;
  }
}

// 广度优先遍历函数
function bfsWithUpwardSearch(startNode, targetValue) {
  const queue = [];
  queue.push(startNode);

  while (queue.length > 0) {
    const currentNode = queue.shift();

    // 查找到目标值时返回父节点
    if (currentNode.value === targetValue) {
      return currentNode.parent;
    }

    // 将当前节点的父节点和上一层的节点入队
    if (currentNode.parent) {
      queue.push(currentNode.parent);
    }
    if (currentNode.parent && currentNode.parent.parent) {
      queue.push(currentNode.parent.parent);
    }

    // 将当前节点的子节点入队
    for (const childNode of currentNode.children) {
      queue.push(childNode);
    }
  }

  // 未找到目标值时返回null
  return null;
}

// 创建树结构
const root = new Node('A');
const nodeB = new Node('B');
const nodeC = new Node('C');
const nodeD = new Node('D');
const nodeE = new Node('E');
const nodeF = new Node('F');

root.addChild(nodeB);
root.addChild(nodeC);
nodeB.addChild(nodeD);
nodeB.addChild(nodeE);
nodeC.addChild(nodeF);

// 在树中向上查找节点
const targetNode = bfsWithUpwardSearch(nodeF, 'B');

if (targetNode) {
  console.log('找到目标节点:', targetNode.value);
} else {
  console.log('未找到目标节点');
}
```

定义了一个Node类来表示树或图中的节点，每个节点包含一个值（value）、父节点（parent）和子节点列表（children）

然后，我们定义了一个bfsWithUpwardSearch函数来实现广度优先遍历，并在遍历的过程中进行向上查找。在每次迭代中，我们检查当前节点的值是否等于目标值，如果是则返回其父节点作为结果。同时，我们将当前节点的父节点和上一层的节点入队，以便在后续迭代中继续向上查找。此外，我们也将当前节点的子节点入队，以保证广度优先遍历的特性

最后，我们创建了一个简单的树结构，并调用bfsWithUpwardSearch函数来在树中向上查找节点。在这个示例中，我们以nodeF作为起始节点，并查找值为'B'的目标节点

如果找到目标节点，则输出"找到目标节点："加上目标节点的值；如果未找到目标节点，则输出"未找到目标节点"
